#include "pch.h"
#include "Common.h"

using namespace std;

void write_parser_code(map<int, map<string, int>>& GOTO, map<int, map<string, pair<string, int>>>& action,
	const unordered_set<string>& terminal, const unordered_set<string>& noter, const ProducerVecStr pro, const string& definition, const string& code)
{
	int termNum = terminal.size();
	int noterNum = noter.size();
	int statesNum = action.size();
	string opt, type;

	ofstream out;

	vector<string> termVec;
	vector<string> noterVec;
	unordered_map<string, int> termMap;
	unordered_map<string, int> noterMap;

	for (auto t : terminal) {
		termMap[t] = termVec.size();
		termVec.push_back(t);
	}

	for (auto n : noter) {
		noterMap[n] = noterVec.size();
		noterVec.push_back(n);
	}

	if (_mkdir("yacc_out") == 0)
	{
		printf("Directory 'yacc_out' was successfully created\n");
	}
	else
		printf("Directory 'yacc_out' already exists\n");

	out.open("yacc_out/yacc.cpp", ios::out);

	out << definition;

	out << "\n// The following are generated by Yacc\n" << endl;

	out << "vector<string> termVec {\n";

	for (size_t i = 0; i < termVec.size(); i++)
	{
		opt += "\t\"" + termVec[i] + "\",\n";
	}
	opt.pop_back(); opt.pop_back();
	opt += "\n};\n\n";
	out << opt;
	opt.clear();

	out << "vector<string> noterVec {\n";

	for (size_t i = 0; i < noterVec.size(); i++)
	{
		opt += "\t\"" + noterVec[i] + "\",\n";
	}
	opt.pop_back(); opt.pop_back();
	opt += "\n};\n\n";
	out << opt;
	opt.clear();

	out << "unordered_map<string, unsigned char> termMap {\n";
	for (size_t i = 0; i < termVec.size(); i++)
	{
		opt += "\t{\"" + termVec[i] + "\", " + to_string(i) + "},\n";
	}
	opt.pop_back(); opt.pop_back();
	opt += "\n};\n\n";
	out << opt;
	opt.clear();

	out << "unordered_map<string, unsigned char> noterMap {\n";
	for (size_t i = 0; i < noterMap.size(); i++)
	{
		opt += "\t{\"" + noterVec[i] + "\", " + to_string(i) + "},\n";
	}
	opt.pop_back(); opt.pop_back();
	opt += "\n};\n\n";
	out << opt;
	opt.clear();

	out << "map<short, map<short, short>> GOTO {\n";
	for (size_t i = 0; i < statesNum; i++)
	{
		int ct = 0;
		for (auto s : noter) {
			if (GOTO[i][s] != -1) ct++;
		}
		if (ct == 0) {
			if (i == statesNum) opt += "}, ";
			continue;
		}
		opt += "\t{" + to_string(i) + ", {";
		for (auto s : noter) {
			int w = GOTO[i][s];
			if (w != -1) {
				opt += "{" + to_string(noterMap[s]) + ", " + to_string(w) + "}, ";
			}
		}
		opt.pop_back(); opt.pop_back();
		opt += "}},\n";
	}
	opt.pop_back(); opt.pop_back();
	opt += "\n};\n\n";
	out << opt;
	opt.clear();

	out << "map<short, short> ACTION[" << statesNum << "] {\n";
	for (size_t i = 0; i < statesNum; i++)
	{
		opt += "\t{";
		for (auto s : terminal) {
			auto r = action[i][s];
			type = r.first;
			if (type == "n") continue;
			opt += "{" + to_string(termMap[s]) + ", ";
			if (type == "s") {
				opt += to_string(r.second);
			}
			else if (type == "r") {
				opt += "-" + to_string(r.second);
			}
			else if (type == "acc") {
				opt += "0";
			}
			opt += "}, ";
		}
		opt.pop_back(); opt.pop_back();
		opt += "},\n";
	}
	opt.pop_back(); opt.pop_back();
	opt += "\n};\n\n";
	out << opt;
	opt.clear();

	out << "pair<string, vector<string>> pvs[" << pro.size() << "] {\n";
	for (auto p : pro) {
		opt += "\t{\"" + p.first + "\", {";
		for (auto r : p.second) {
			opt += "\"" + r + "\", ";
		}
		opt.pop_back(); opt.pop_back();
		opt += "}},\n";
	}
	opt.pop_back(); opt.pop_back();
	opt += "\n};\n\n";
	out << opt;
	opt.clear();

	out << "\n// The following are from the yacc file" << endl;

	out << code;

	out.close();
}